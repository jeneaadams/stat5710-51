---
title: "Modern Data Mining, HW 2"
author:
- Group Member 1 - Jenea Adams
- Group Member 2 - Annan Timon
date: 'Due: 11:59 PM,  Sunday, 02/12'
output:
  html_document:
    code_folding: show
    highlight: haddock
    number_sections: yes
    theme: lumen
    toc: yes
    toc_depth: 4
    toc_float: yes
  pdf_document:
    extra_dependencies: ["dcolumn"]
    number_sections: yes
    toc: yes
    toc_depth: '4'
  word_document:
    toc: yes
    toc_depth: '4'
urlcolor: blue
---

# Packages

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results = "hide", fig.width=8, fig.height=4)
# get the output format for stargazer only:
# results = `asis`
# stargazer( type = ) one of the following:
## if run in studio, set as "text"
## if knit to PDF, set as "latex"
## if knit to HTML, set as "html"
# We made it automatic:

output_format <- ifelse(is.null(knitr::opts_knit$get("rmarkdown.pandoc.to")),
                        "text", knitr::opts_knit$get("rmarkdown.pandoc.to"))

options(scipen = 0, digits = 3)  # controls base R output
if(!require('pacman')) {
  install.packages('pacman')
}
pacman::p_load(ISLR, tidyverse, data.table, ggpubr, ggbiplot, ggplot2, factoextra,
               dplyr, knitr, gridExtra, ggrepel, leaps, car, tidyverse,
               stargazer, cluster, ) # add the packages needed
```


\pagebreak

# Overview {-}

Principle Component Analysis is widely used in data exploration, dimension reduction, data visualization. The aim is to transform original data into uncorrelated linear combinations of the original data while keeping the information contained in the data. High dimensional data tends to show clusters in lower dimensional view. 

Clustering Analysis is another form of EDA. Here we are hoping to group data points which are close to each other within the groups and far away between different groups. Clustering using PC's can be effective. Clustering analysis can be very subjective in the way we need to summarize the properties within each group. 

Both PCA and Clustering Analysis are so called unsupervised learning. There is no response variables involved in the process. 

For supervised learning, we try to find out how does a set of predictors relate to some response variable of the interest. Multiple regression is still by far, one of the most popular methods. We use a linear models as a working model for its simplicity and interpretability. It is important that we use domain knowledge as much as we can to determine the form of the response as well as the function format of the factors on the other hand. 


## Objectives

- PCA
- SVD
- Clustering Analysis
- Linear Regression

## Review materials

- Study Module 2: PCA
- Study Module 3: Clustering Analysis
- Study Module 4: Multiple regression

## Data needed

- `NLSY79.csv`
- `brca_subtype.csv`
- `brca_x_patient.csv`


# Case study 1: Self-seteem 

Self-esteem generally describes a person's overall sense of self-worthiness and personal value. It can play significant role in one's motivation and success throughout the life. Factors that influence self-esteem can be inner thinking, health condition, age, life experiences etc. We will try to identify possible factors in our data that are related to the level of self-esteem. 

In the well-cited National Longitudinal Study of Youth (NLSY79), it follows about 13,000 individuals and numerous individual-year information has been gathered through surveys. The survey data is open to public [here](https://www.nlsinfo.org/investigator/). Among many variables we assembled a subset of variables including personal demographic variables in different years, household environment in 79, ASVAB test Scores in 81 and Self-Esteem scores in 81 and 87 respectively. 

The data is store in `NLSY79.csv`.

```{r  message=F, echo =F}
nlsy = read.csv("data/NLSY79.csv", header = T)
```

```{r  message=F, echo =F}
# head(nlsy)
```



Here are the description of variables:

**Personal Demographic Variables**

* Gender: a factor with levels "female" and "male"
* Education05: years of education completed by 2005
* HeightFeet05, HeightInch05: height measurement. For example, a person of 5'10 will be recorded as HeightFeet05=5, HeightInch05=10.
* Weight05: weight in lbs.
* Income87, Income05: total annual income from wages and salary in 2005. 
* Job87 (missing), Job05: job type in 1987 and 2005, including Protective Service Occupations, Food Preparation and Serving Related Occupations, Cleaning and Building Service Occupations, Entertainment Attendants and Related Workers, Funeral Related Occupations, Personal Care and Service Workers, Sales and Related Workers, Office and Administrative Support Workers, Farming, Fishing and Forestry Occupations, Construction Trade and Extraction Workers, Installation, Maintenance and Repairs Workers, Production and Operating Workers, Food Preparation Occupations, Setters, Operators and Tenders,  Transportation and Material Moving Workers
 
 
**Household Environment**
 
* Imagazine: a variable taking on the value 1 if anyone in the respondent’s household regularly read magazines in 1979, otherwise 0
* Inewspaper: a variable taking on the value 1 if anyone in the respondent’s household regularly read newspapers in 1979, otherwise 0
* Ilibrary: a variable taking on the value 1 if anyone in the respondent’s household had a library card in 1979, otherwise 0
* MotherEd: mother’s years of education
* FatherEd: father’s years of education
* FamilyIncome78

**Variables Related to ASVAB test Scores in 1981**

Test | Description
--------- | ------------------------------------------------------
AFQT | percentile score on the AFQT intelligence test in 1981 
Coding | score on the Coding Speed test in 1981
Auto | score on the Automotive and Shop test in 1981
Mechanic | score on the Mechanic test in 1981
Elec | score on the Electronics Information test in 1981
Science | score on the General Science test in 1981
Math | score on the Math test in 1981
Arith | score on the Arithmetic Reasoning test in 1981
Word | score on the Word Knowledge Test in 1981
Parag | score on the Paragraph Comprehension test in 1981
Numer | score on the Numerical Operations test in 1981

**Self-Esteem test 81 and 87**

We have two sets of self-esteem test, one in 1981 and the other in 1987. Each set has same 10 questions. 
They are labeled as `Esteem81` and `Esteem87` respectively followed by the question number.
For example, `Esteem81_1` is Esteem question 1 in 81.

The following 10 questions are answered as 1: strongly agree, 2: agree, 3: disagree, 4: strongly disagree

* Esteem 1: “I am a person of worth”
* Esteem 2: “I have a number of good qualities”
* Esteem 3: “I am inclined to feel like a failure”
* Esteem 4: “I do things as well as others”
* Esteem 5: “I do not have much to be proud of”
* Esteem 6: “I take a positive attitude towards myself and others”
* Esteem 7: “I am satisfied with myself”
* Esteem 8: “I wish I could have more respect for myself”
* Esteem 9: “I feel useless at times”
* Esteem 10: “I think I am no good at all”

## Data preparation

_Load the data. Do a quick EDA to get familiar with the data set. Pay attention to the unit of each variable. Are there any missing values?_

```{r quick skim of the data}
# temp <- read.csv('data/NLSY79.csv', header = T, stringsAsFactors = F)
# # missing values? real variables vs. factors? are varable values reasonable?
str(nlsy)
summary(nlsy)

levels(as.factor(nlsy$Job05))
table(as.factor(nlsy$Job05))
```

```{r  message=F, echo =F}
names(nlsy)
```

### Subject demographics 
```{r gender pie chart}
gender_pie = nlsy %>%
  ggplot(aes(x = "", y = Gender, fill = Gender)) + 
  geom_bar(stat ="identity", width = 1) + 
  coord_polar("y", start=0) + 
  theme_void()

gender_pie
```


```{r education histogram}
edu_hist = nlsy %>%
  ggplot() + 
  geom_histogram(aes(x = Education05), bins = 15, color ="white", fill = "orange") + 
  labs(title = "Historgram of Years of Education completed by 2005", subtitle = "Mean Education Level shown by red line", x = "Years of Education", y = "frequency") +
  geom_vline(aes(xintercept=mean(Education05)),
             color = "red", linetype = "dashed", size = 1)

edu_hist
```



```{r barplot of 2005 jobs}
job_bar = nlsy %>%
  # filter(!Job05=="") %>%
  ggplot(aes(x = Job05, fill = Job05)) + 
  geom_bar() + 
  theme(legend.position = "none",
        # adjust for margins around the plot; t: top; r: right; b: bottom; l: left, 
        axis.text.x = element_text(angle = -90, vjust = 0, hjust = 0))

job_bar
```


paired visualization of income in 87 and income in 05 
```{r  message=F, echo =F}

nlsy %>%
  filter(!Income87 == "" & !Income05 == "" & !Job05 =="") %>%
  ggpaired(cond1 = "Income87", cond2 = "Income05", color = "condition",line.color = "gray", line.size = 0.1, palette = "npg") + 
  labs(title = "Income in 1987 and 2005 for paired subjects with a job in 2005")

```

Family income to 87 and 2005 income + gender + weight

```{r  message=F, echo =F}
nlsy %>%
  ggplot(aes(x=Income05, y = FamilyIncome78, col = Gender, size = Weight05, shape = , alpha = 0.3)) + 
  geom_point()

```


  
```{r  message=F, echo =F}
nlsy %>%
  ggplot(aes(x=MotherEd, y = FatherEd, col = Gender, size = Income05 , alpha = 0.3)) + 
  geom_point()

```
  
```{r  message=F, echo =F}
nlsy %>%
  ggplot(aes(x=Income05, y = FamilyIncome78, col = Gender, size = Weight05, shape = as.factor(Ilibrary) , alpha = 0.3)) + 
  geom_point()

```


_How many people believe they are a person of worth in 87, and how is this affected by gender and income in 05?_

```{r  message=F, echo =F}
nlsy %>%
  ggplot(aes(x = Esteem87_1, fill = Gender)) +
  geom_bar(position = "dodge") +
  # facet_grid(as.factor(Inewspaper)~., scales = "free_y") +
  theme(axis.text.x = element_text(angle = 0, hjust = 1)) +
  ggtitle("")
```


_by parents reading the newspaper_
```{r  message=F, echo =F}

nlsy %>%
  ggplot(aes(x = Esteem87_1, fill = Gender)) +
  geom_bar(position = "dodge") +
  facet_grid(as.factor(Inewspaper)~., scales = "free_y") +
  theme(axis.text.x = element_text(angle = 0, hjust = 1)) +
  ggtitle("")
```

_feeling useless: 1: strongly agree, 2: agree, 3: disagree, 4: strongly disagree_
```{r  message=F, echo =F}
nlsy %>%
  ggplot(aes(x = Esteem87_9, fill = Gender)) +
  geom_bar(position = "dodge") +
  facet_grid(as.factor(Inewspaper)~., scales = "free_y") +
  theme(axis.text.x = element_text(angle = 0, hjust = 1)) +
  ggtitle("")
```

```{r  message=F, echo =F}
nlsy %>%
  ggplot(aes(x = Esteem87_9, fill = Gender)) +
  geom_bar(position = "dodge") +
  # facet_grid(as.factor(Inewspaper)~., scales = "free_y") +
  theme(axis.text.x = element_text(angle = 0, hjust = 1)) +
  ggtitle("")
```


_Of those who agreed with feeling useless in 87, what was their income in 87 and weight_
```{r  message=F, echo =F}
nlsy %>%
  filter(Esteem87_9 <=2) %>%
  ggplot(aes(x=Income87, y = Weight05, col = Gender, size = FamilyIncome78, alpha = 0.3)) + 
  geom_point() + 
  labs(title = "Income in 87 wrt Family Income, Gender, and Weight")

```


### Missing values 
```{r  message=F, echo =F}
missing.nlsy = nlsy %>%
  summarise(nas = sum(is.na(nlsy)),
            blanks = sum(nlsy == ""))
missing.nlsy
```

_From looking at the jobs barplots, it's posisble those with missing values could come from missing job types. These people may be unemployed, which is different than having a job that was "uncodeable". Therefore, I'm deciding not to remove thise entries as it could still be informative given there are several individuals who report income as 0_



## Self esteem evaluation

Let concentrate on Esteem scores evaluated in 87. 

The following 10 questions are answered as 1: strongly agree, 2: agree, 3: disagree, 4: strongly disagree

* Esteem 1: “I am a person of worth”
* Esteem 2: “I have a number of good qualities”
* Esteem 3: “I am inclined to feel like a failure”
* Esteem 4: “I do things as well as others”
* Esteem 5: “I do not have much to be proud of”
* Esteem 6: “I take a positive attitude towards myself and others”
* Esteem 7: “I am satisfied with myself”
* Esteem 8: “I wish I could have more respect for myself”
* Esteem 9: “I feel useless at times”
* Esteem 10: “I think I am no good at all”
_
```{r  message=F, echo =F}
labels = c("person of worth","good qualities", "feel like a failure", "do things as well as others", "not proud of much", "positive toward self & others", "satisfied w/self", "wish more self-respect", "feel useless", "I'm no good")
```


0. First do a quick summary over all the `Esteem` variables. Pay attention to missing values, any peculiar numbers etc. How do you fix problems discovered if there is any? Briefly describe what you have done for the data preparation. 

```{r  message=F, echo =F}
nlsy %>%
  select(contains("Esteem87"), ) %>%
  summarise(nas = sum(is.na(.)),
            blanks = sum(. == ""))

data.esteem = nlsy %>%
  select(contains("Esteem87"))
```
_There appear to be no blanks or NAs_


1. Reverse Esteem 1, 2, 4, 6, and 7 so that a higher score corresponds to higher self-esteem. (Hint: if we store the esteem data in `data.esteem`, then `data.esteem[,  c(1, 2, 4, 6, 7)]  <- 5 - data.esteem[,  c(1, 2, 4, 6, 7)]` to reverse the score.)

```{r  message=F, echo =F}
data.esteem[,  c(1, 2, 4, 6, 7)]  = 5 - data.esteem[,  c(1, 2, 4, 6, 7)]

```


2. Write a brief summary with necessary plots about the 10 esteem measurements.

```{r  message=F, echo =F}
# data.esteem
```

```{r  message=F, echo =F}

```
```{r  message=F, echo =F}
# data.esteem%>%
#   ggplot(aes(x = Esteem87_1, fill = Gender)) +
#   geom_bar(position = "dodge") +
#   facet_grid(as.factor(Inewspaper)~., scales = "free_y") +
#   theme(axis.text.x = element_text(angle = 0, hjust = 1)) +
#   ggtitle("")
```


3. Are esteem scores all positively correlated? Report the pairwise correlation table and write a brief summary.

```{r  message=F, echo =F}
plot(data.esteem)
```
```{r  message=F, echo =F}
cov(data.esteem)
```
_The esteem scores are all positively correlated._

```{r  message=F, echo =F}
# corrplot::corrplot(data.esteem)
```


4. PCA on 10 esteem measurements. (centered but no scaling)

    a) Report the PC1 and PC2 loadings. Are they unit vectors? Are they orthogonal? 
    
```{r centering}
data.esteem.centered = scale(data.esteem, center = T, scale = F)
data.esteem.centered <- as.data.frame(data.esteem.centered)

```
    
    
```{r plotting old and new means and SDs}
round(sapply(data.esteem.centered,mean), 3) # col mean with 3 decimals
sapply(data.esteem, mean) # col mean
sapply(data.esteem.centered, sd) #col sd
sapply(data.esteem, sd) # col sd
```
    
  _Here we see the new mean centered at 0 but the standard deviation is the same as the uncentered data_
    
```{r  message=F, echo =F}
pc.data.esteem.centered = data.esteem.centered %>%
  prcomp(scale.= F)

pc.data.esteem.centered
```
```{r  message=F, echo =F}
summary(pc.data.esteem.centered)
```
```{r  message=F, echo =F}
loadings.esteem = data.frame(pc1 = abs(pc.data.esteem.centered$rotation[,1]),
                      pc2 = abs(pc.data.esteem.centered$rotation[,2]))

# knitr::kable(loadings.esteem)
loadings.esteem = pc.data.esteem.centered$rotation
loadings.esteem
```


```{r  message=F, echo =F}
pc.data.esteem.centered$rotation
```
    
```{r  message=F, echo =F}
round(t(loadings.esteem) %*% loadings.esteem) 
```
 
```{r  message=F, echo =F}
colSums((loadings.esteem)^2)
```
 
  _All loadings are perpendicular and with unit 1_

  
  
    b) Are there good interpretations for PC1 and PC2? (If loadings are all negative, take the positive loadings for the ease of interpretation)
    
    
  Loadings determine the contribution of each variable to the PCs.    
  PC1 loadings are all positively correlated with the esteem features, given their positive loadings.
  PC2 had loadings which are mostly negatively correlated with the esteem features, besides the final three.
  
  These loadings could indicate that the 6 loadings in PC1 with values over 0.300 contribute more to PC1. Also Esteem87_9's loading in PC2 is one of three positively correlated with PC2 and also has the strongest contribution to the PC. 
    
  
    c) How is the PC1 score obtained for each subject? Write down the formula.
    
  PC1 = 0.235 x Esteem87_1 + 0.244 x Esteem87_2 + 0.279 x Esteem87_3 + 0.261 x Esteem87_4 + 0.312 x Esteem87_5 + 0.313 x Esteem87_6 + 0.299 x Esteem87_7 + 0.393 x Esteem87_8 + 0.398 x Esteem87_9 + 0.376 x Esteem87_10
    
    d) Are PC1 scores and PC2 scores in the data uncorrelated? 
  
```{r  message=F, echo =F}
round(cov(pc.data.esteem.centered$x), 4) 
```
  
```{r  message=F, echo =F}
pairs(pc.data.esteem.centered$x, xlim=c(-4, 4), ylim=c(-4, 4), col=rainbow(6), pch=16)
```
  
  _There appears to be no correlation between the PCs_
    
    
    e) Plot PVE (Proportion of Variance Explained) and summarize the plot. 
    
```{r  message=F, echo =F}
round((pc.data.esteem.centered$sdev)^2, 2)
```
```{r  message=F, echo =F}
summary(pc.data.esteem.centered)$importance
```
```{r  message=F, echo =F}
plot(pc.data.esteem.centered)
```
    
    
  _PC1 captures a large percetnage of the variance and each subsequent princial component explaines lessa variance than the preceeding one._
  
```{r  message=F, echo =F}
plot(summary(pc.data.esteem.centered)$importance[2, ],  # PVE
     ylab="PVE",
     xlab="Number of PCs",
     pch = 16, 
     main="Scree Plot of PVE for AFQT")
```
  
  _PC1 captures about 40% of the variance and PC2 about 10%_
  
  
    f) Also plot CPVE (Cumulative Proportion of Variance Explained). What proportion of the variance in the data is explained by the first two principal components?
    
```{r  message=F, echo =F}
plot(summary(pc.data.esteem.centered)$importance[3, ], pch=16,
     ylab="Cumulative PVE",
     xlab="Number of PCs",
     main="Scree Plot of Cumulative PVE for AFQT")
```
    
  _Cumulatively, about 60% of the variance in this data is explained by the first 2 PCs_
  
    g) PC’s provide us with a low dimensional view of the self-esteem scores. Use a biplot with the first two PC's to display the data.  Give an interpretation of PC1 and PC2 from the plot. (try `ggbiplot` if you could, much prettier!)
    
```{r  message=F, echo =F}
library("devtools")
install_github("kassambara/factoextra")
devtools::install_github("sinhrks/ggfortify")
library(ggfortify)
```
    
    
```{r  message=F, echo =F}
# fviz_pca_biplot(pc.data.esteem.centered)
```
    
```{r  message=F, echo =F}
autoplot(pc.data.esteem.centered, label = TRUE, loadings.label = TRUE)
```
    
  _This biplot shows that the PC1 loadings are similarin magnitudes and signs. It also shows that PC2 shoudl capture the differences in responses to questions 8, 9 and 10 from the other questions. This also means questions 8, 9, and 10 are more correlated than the other questions (features)  ._

5. Apply k-means to cluster subjects on the original esteem scores

    a) Find a reasonable number of clusters using within sum of squares with elbow rules.
    
```{r  message=F, echo =F}
wss =  function(data.esteem, k) {
kmeans(data.esteem, k, nstart = 10)$tot.withinss
}

k.values = 2:15

wss_values = sapply(k.values,
                    function(k) kmeans(data.esteem[,-1], centers = k)$tot.withinss)

plot(k.values, wss_values,
     type="b", pch = 19, frame = FALSE,
     xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares")
```
```{r  message=F, echo =F}
library(factoextra)
fviz_nbclust(data.esteem[,-1], kmeans, method = "wss")
```
    
    b) Can you summarize common features within each cluster?
```{r  message=F, echo =F}
# system.time({esteem.kmeans = kmeans(x = data.esteem, 2)})
esteem.kmeans = kmeans(x = data.esteem, 2)
# names(esteem.kmeans)
# summary(esteem.kmeans)
print(esteem.kmeans)

```
```{r  message=F, echo =F}
head(esteem.kmeans$cluster, 4)
```
  
```{r  message=F, echo =F}
esteem.kmeans$size
```
  
```{r  message=F, echo =F}
fviz_cluster(esteem.kmeans, data = data.esteem)
```
  
    
```{r  message=F, echo =F}
data.esteem %>%
  as_tibble() %>%
  mutate(cluster = esteem.kmeans$cluster,
         question = row.names(data.esteem)) %>%
  ggplot(aes(Esteem87_1, Esteem87_10, color = factor(cluster), label = question)) +
  geom_text()
```
    _this shows that those with the highest self esteem are mostly in cluster 1 while others are in cluster 2. These are people who agree with a positive statement and disagree with a negative stateent._
    
    c) Can you visualize the clusters with somewhat clear boundaries? You may try different pairs of variables and different PC pairs of the esteem scores. 
    
```{r  message=F, echo =F}
as.data.frame(pc.data.esteem.centered$x) %>% 
  mutate(cluster = esteem.kmeans$cluster,
         question = row.names(data.esteem)) %>%
  ggplot(aes(x=PC1, y=PC2)) +    # Try other PCs vs. PC1, any patterns?
  geom_point(aes(color= as.factor(cluster)))+
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  ggtitle("PC2 vs. PC1 for Self Esteem ") +
  theme_bw()
```
    
    
```{r  message=F, echo =F}
as.data.frame(pc.data.esteem.centered$x) %>% 
  mutate(cluster = esteem.kmeans$cluster,
         question = row.names(data.esteem)) %>%
  ggplot(aes(x=PC1, y=PC3)) +    # Try other PCs vs. PC1, any patterns?
  geom_point(aes(color= as.factor(cluster)))+
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  ggtitle("PC3 vs. PC1 for Self Esteem ") +
  theme_bw()
```
    
```{r  message=F, echo =F}
as.data.frame(pc.data.esteem.centered$x) %>% 
  mutate(cluster = esteem.kmeans$cluster,
         question = row.names(data.esteem)) %>%
  ggplot(aes(x=PC1, y=PC4)) +    # Try other PCs vs. PC1, any patterns?
  geom_point(aes(color= as.factor(cluster)))+
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  ggtitle("PC4 vs. PC1 for Self Esteem ") +
  theme_bw()
```
    
```{r  message=F, echo =F}
as.data.frame(pc.data.esteem.centered$x) %>% 
  mutate(cluster = esteem.kmeans$cluster,
         question = row.names(data.esteem)) %>%
  ggplot(aes(x=PC1, y=PC5)) +    # Try other PCs vs. PC1, any patterns?
  geom_point(aes(color= as.factor(cluster)))+
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  ggtitle("PC5 vs. PC1 for Self Esteem ") +
  theme_bw()
```
    
```{r  message=F, echo =F}
data.esteem %>%
  as_tibble() %>%
  mutate(cluster = esteem.kmeans$cluster,
         question = row.names(data.esteem)) %>%
  ggplot(aes(Esteem87_8, Esteem87_9, color = factor(cluster), label = question)) +
  geom_text()
```
    
```{r  message=F, echo =F}
data.esteem %>%
  as_tibble() %>%
  mutate(cluster = esteem.kmeans$cluster,
         question = row.names(data.esteem)) %>%
  ggplot(aes(Esteem87_3, Esteem87_9, color = factor(cluster), label = question)) +
  geom_text()
```
    


6. We now try to find out what factors are related to self-esteem? PC1 of all the Esteem scores is a good variable to summarize one's esteem scores. We take PC1 as our response variable. 

```{r  message=F, echo =F}
nlsy = nlsy %>%
  mutate(PC1.esteem = pc.data.esteem.centered$x[,1])
```


    a) Prepare possible factors/variables:
    
      - EDA the data set first. 

      - Personal information: gender, education (05), log(income) in 87, job type in 87. Weight05 (lb) and HeightFeet05 together with Heightinch05. One way to summarize one's weight and height is via Body Mass Index which is defined as the body mass divided by the square of the body height, and is universally expressed in units of kg/m². Note, you need to create BMI first. Then may include it as one possible predictor. 
      

```{r  message=F, echo =F}
nlsy = nlsy %>%
  mutate(ft2m = HeightFeet05 / 3.281,
         in2m = HeightFeet05 / 39.37,
         totalheight = ft2m + in2m,
         kg = Weight05 / 2.205,
         bmi = kg / (totalheight^2))

head(nlsy)
```
      
          
      - Household environment: Imagazine, Inewspaper, Ilibrary, MotherEd, FatherEd, FamilyIncome78. Do set indicators `Imagazine`, `Inewspaper` and `Ilibrary` as factors. 
```{r  message=F, echo =F}
nlsy$Imagazine = as.factor(nlsy$Imagazine)
nlsy$Inewspaper = as.factor(nlsy$Inewspaper)
nlsy$Ilibrary = as.factor(nlsy$Ilibrary)

head(nlsy)
```
      
    
      - You may use PC1 of ASVAB as level of intelligence
      **Variables Related to ASVAB test Scores in 1981**

Test | Description
--------- | ------------------------------------------------------
AFQT | percentile score on the AFQT intelligence test in 1981 
Coding | score on the Coding Speed test in 1981
Auto | score on the Automotive and Shop test in 1981
Mechanic | score on the Mechanic test in 1981
Elec | score on the Electronics Information test in 1981
Science | score on the General Science test in 1981
Math | score on the Math test in 1981
Arith | score on the Arithmetic Reasoning test in 1981
Word | score on the Word Knowledge Test in 1981
Parag | score on the Paragraph Comprehension test in 1981
Numer | score on the Numerical Operations test in 1981

```{r  message=F, echo =F}
asvab = nlsy %>%
  select(AFQT, Coding, Auto, Mechanic, Elec, Science, Number)

# asvab%>%
#   mutate(word_centered = `Word` - mean(Word),
#          parag_centered = `Parag` - mean(Parag))
# # Making word and parag by centering each score.
# 
# # or use scale() to center the data
# parag.word.centered <- scale(AFQT.sub[, c("Parag", "Word")], 
#                                            center = T, scale = F)
# parag.word.centered <- as.data.frame(parag.word.centered)

asvab = as.data.frame(scale(asvab, center = T, scale = T))
```
      
```{r  message=F, echo =F}
pc.asvab = prcomp(asvab, scale = T)

names(pc.asvab)

pc.asvab.loading = pc.asvab$rotation
pc.asvab.loading
```

```{r  message=F, echo =F}
head(pc.asvab$x)
```
```{r  message=F, echo =F}

```

```{r  message=F, echo =F}
plot(summary(pc.asvab)$importance[2, ],  # PVE
     ylab="PVE",
     xlab="Number of PCs",
     pch = 16, 
     main="Scree Plot of PVE for ASVAB")
```

```{r  message=F, echo =F}
autoplot(pc.asvab, label = TRUE, loadings.label = TRUE)
```

```{r  message=F, echo =F}
as.data.frame(pc.asvab$x) %>% 
  ggplot(aes(x=PC1, y=PC2)) +
  geom_point()+
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  ggtitle("PC2 vs. PC1 for ASVAB") +
  theme_bw()
```

      
```{r  message=F, echo =F}
asvab.nlsy.PC.Scores = cbind(scale(asvab, scale = TRUE), pc.asvab$x)
arrange(as.data.frame(asvab.nlsy.PC.Scores), desc(PC1)) %>%
     head()
```
```{r  message=F, echo =F}
nlsy = nlsy %>%
  mutate(intelligence = pc.asvab$x[,1])

head(nlsy)
```
      
      
### regression models
  
    b)   Run a few regression models between PC1 of all the esteem scores and suitable variables listed in a). Find a final best model with your own criterion. 
    
```{r  message=F, echo =F}
nlsy$Gender = as.factor(nlsy$Gender)
```
    
_bmi_
```{r  message=F, echo =F}
fit1 = lm(data = nlsy, formula = PC1.esteem ~ bmi)
summary(fit1)
```
_intelligence_
```{r  message=F, echo =F}
fit2 = nlsy %>%
  lm(formula = PC1.esteem ~ intelligence)
summary(fit2)
```
    
  _Gender_
```{r  message=F, echo =F}
fit3 = nlsy %>%
  lm(formula = PC1.esteem ~ Gender)
summary(fit3)
```
 _Since we saw slight diffferences in esteem scores across gender and newspaper indicators, we can run a model against these features _
```{r  message=F, echo =F}
fit4a = nlsy %>%
  lm(formula = PC1.esteem ~ Inewspaper)
summary(fit4a)

```
  
```{r  message=F, echo =F}
fit4b = nlsy %>%
  lm(formula = PC1.esteem ~ Inewspaper + Gender)
summary(fit4b)
```
  _These results may warrant further investigation into a potential linear relationship between Males, newspaper usage at home, and esteem scores._
  

Personal information: gender, education (05), log(income) in 87, job type in 87.



_combing Personal info_

```{r  message=F, echo =F}
fit5 = nlsy %>%
  lm(formula = PC1.esteem ~ Gender + Education05)
summary(fit5)
```

```{r  message=F, echo =F}
fit6 = nlsy %>%
  drop_na() %>%
  filter(Income87 >0) %>%
  mutate(logincome = log(Income87)) %>%
  lm(formula = PC1.esteem ~ Gender + Education05 + logincome)
summary(fit6)
```
_Here we see the effect of Male gender become insignificant when we control for log(income) in 87._

```{r  message=F, echo =F}
fit7 = nlsy %>%
  drop_na() %>%
  lm(formula = PC1.esteem ~ Gender + Education05 + Job05)
summary(fit7)
```

_These models are only explaining less than 1% of the variation in the esteem data, however. Let's look at household environment features_

    - Household environment: Imagazine, Inewspaper, Ilibrary, MotherEd, FatherEd, FamilyIncome78. Do set indicators `Imagazine`, `Inewspaper` and `Ilibrary` as factors. 

```{r  message=F, echo =F}
fit8 = nlsy %>%
  drop_na() %>%
  lm(formula = PC1.esteem ~ Imagazine + Inewspaper + Ilibrary + MotherEd + FatherEd + FamilyIncome78)
summary(fit8)

```

```{r  message=F, echo =F}
fit9 = nlsy %>%
  drop_na() %>%
  lm(formula = PC1.esteem ~ Inewspaper + MotherEd + Ilibrary + FamilyIncome78)
summary(fit9)
```


_Combining more personal info with home environment_ 

```{r  message=F, echo =F}
fit10 = nlsy %>%
  drop_na() %>%
  filter(Income87 >0) %>%
  mutate(logincome = log(Income87)) %>%
  lm(formula = PC1.esteem ~ Gender + Education05 + logincome + Inewspaper + MotherEd + FatherEd + Ilibrary + FamilyIncome78)
summary(fit10)

```


```{r  message=F, echo =F}
fit11 = nlsy %>%
  drop_na() %>%
  filter(Income87 >0) %>%
  mutate(logincome = log(Income87)) %>%
  lm(formula = PC1.esteem ~ Gender + logincome  + FatherEd + MotherEd + Imagazine + bmi)
summary(fit11)
```
```{r  message=F, echo =F}
fit12 = nlsy %>%
  drop_na() %>%
  filter(Income87 >0) %>%
  mutate(logincome = log(Income87)) %>%
  lm(formula = PC1.esteem ~ Gender + logincome + MotherEd + Job05 + bmi + intelligence + FamilyIncome78)
# summary(fit12)
```

```{r  message=F, echo =F}
fit13 = nlsy %>%
  drop_na() %>%
  filter(Income87 >0) %>%
  mutate(logincome = log(Income87)) %>%
  lm(formula = PC1.esteem ~ Gender + logincome + MotherEd + Inewspaper + Imagazine + Ilibrary + Job05 + bmi + intelligence + FamilyIncome78)
# summary(fit13)
```

```{r  message=F, echo =F}
fit14 = nlsy %>%
  drop_na() %>%
  filter(Income87 >0) %>%
  mutate(logincome = log(Income87)) %>%
  lm(formula = PC1.esteem ~ Gender + logincome + MotherEd + Education05 + Inewspaper + Imagazine + Ilibrary + Job05 + bmi + intelligence + FamilyIncome78)
# summary(fit14)
```

```{r  message=F, echo =F}
fit15 = nlsy %>%
  drop_na() %>%
  filter(Income87 >0) %>%
  mutate(logincome = log(Income87)) %>%
  lm(formula = PC1.esteem ~ Gender + logincome + MotherEd + Education05 + Inewspaper  + Job05 + bmi + intelligence + FamilyIncome78)
summary(fit15)
```

_fit15 seems to be the best model so far_
     
  
     
      - How did you land on this model? Run a model diagnosis to see if the linear model assumptions are reasonably met. 
      
  _We are choosing ``fit15`` as our best model given the relatively higher R^2 value and features spanning home envrionment and personal demographics which have a significant linear relationship with PC1._
  
Residual Plot 
```{r  message=F, echo =F}
plot(fit15$fitted, fit15$residuals, 
     pch  = 16,
     main = "residual plot")
abline(h=0, lwd=4, col="red")
```

_There appear to be heteroscedasticity within the model as the variance is not equally distributed across all values of x. In other words, the variance does not appear to be constant, which does not support a linear model assumption._

Check for Normality
  
```{r  message=F, echo =F}
qqnorm(fit15$residuals)
  qqline(fit15$residuals, lwd=4, col="blue")
```
  
_The points in the qqplot deviate significantly from the reference line, indicating the data may not be entirely normally distributed._

_Taken together, we do not believe there is enough evidence that the assumptios of the linear model are met._
        
### Summary

      - Write a summary of your findings. In particular, explain what and how the variables in the model affect one's self-esteem. 
      
  _Given the opposing outcomes of the linear model diagnosis which indicate the linear model assumptions may not be completely met, interpretation of this analysis should proceed with caution, as a linear model may not be the best model for predicting PC1 scores of self esteem. With that in mind, featyures such as male gender, income, education, intelligence, family income, and certain leadership-related job positions seem to have a positive correlation with higher self esteem scores. Features such as BMI and some STEM-related fields appear to have a negative correlation with high self esteem scores. Most of the persional background features such as education, gender, and income appear to have the stronge linear realtionships with self esteem scores. Together, the p-values and $\beta$ coefficients give a complementary picture of the magnitude and directions of linear relationships between these features and show that personal perceptions may be more shaped by personal demographics than family environment._
        



# Case study 2: Breast cancer sub-type


[The Cancer Genome Atlas (TCGA)](https://www.cancer.gov/about-nci/organization/ccg/research/structural-genomics/tcga), a landmark cancer genomics program by National Cancer Institute (NCI), molecularly characterized over 20,000 primary cancer and matched normal samples spanning 33 cancer types. The genome data is open to public from the [Genomic Data Commons Data Portal (GDC)](https://portal.gdc.cancer.gov/).
 
In this study, we focus on 4 sub-types of breast cancer (BRCA): basal-like (basal), Luminal A-like (lumA), Luminal B-like (lumB), HER2-enriched. The sub-type is based on PAM50, a clinical-grade luminal-basal classifier. 

* Luminal A cancers are low-grade, tend to grow slowly and have the best prognosis.
* Luminal B cancers generally grow slightly faster than luminal A cancers and their prognosis is slightly worse.
* HER2-enriched cancers tend to grow faster than luminal cancers and can have a worse prognosis, but they are often successfully treated with targeted therapies aimed at the HER2 protein. 
* Basal-like breast cancers or triple negative breast cancers do not have the three receptors that the other sub-types have so have fewer treatment options.

We will try to use mRNA expression data alone without the labels to classify 4 sub-types. Classification without labels or prediction without outcomes is called unsupervised learning. We will use K-means and spectrum clustering to cluster the mRNA data and see whether the sub-type can be separated through mRNA data.

We first read the data using `data.table::fread()` which is a faster way to read in big data than `read.csv()`. 

```{r  message=FALSE, warning=FALSE, eval = TRUE}
brca <- fread("data/brca_subtype.csv.gz")

# get the sub-type information
brca_subtype <- brca$BRCA_Subtype_PAM50 %>% factor
brca <- brca[,-1]
```

1. Summary and transformation

a) How many patients are there in each sub-type? 
    
```{rmessage=FALSE, warning=FALSE, results='asis', echo=FALSE}
kable(data.frame(t(summary((brca_subtype)))),
     caption = "Patients in each sub-type")
```
    

b) Randomly pick 5 genes and plot the histogram by each sub-type.
    
```{r, warning=FALSE, fig.height=10, fig.width=12, echo=FALSE}
num_gene <- ncol(brca)

# randomly select 10 gene
set.seed(10)
sample_idx <- sample(num_gene, 5)

# plot count number histogram for each gene
brca %>%
  select(c(all_of(sample_idx))) %>%
  cbind(.,brca_subtype) %>% # select column by index
  pivot_longer(-brca_subtype) %>%     # for facet(0)
  ggplot(aes(x = value, y = ..density..)) +
  geom_histogram(aes(fill = brca_subtype)) +
  facet_wrap(~name, scales = "free") +
  theme(legend.position = "none")
```


c) Remove gene with zero count and no variability. Then apply logarithmic transform.
    
278 genes were removed
```{r message=FALSE, warning=FALSE, echo=FALSE}
# remove genes with 0 counts
subset_bool <-colSums(abs(brca)) != 0 & apply(brca,2,var) !=0
sel_cols <- which(subset_bool)
brca_sub <- brca[, sel_cols, with=F]

# log
brca_sub <- log2(as.matrix(brca_sub+1e-10))

dim(brca)
dim(brca_sub)
```


2. Apply kmeans on the transformed dataset with 4 centers and output the discrepancy table between the real sub-type `brca_subtype` and the cluster labels.

```{r message=FALSE, warning=FALSE, results='asis', echo=FALSE}
# system.time() get how long it runs
# it can take several minutes.
system.time({brca_sub_kmeans <- kmeans(x = brca_sub, 4)})

# save the results as RDS
saveRDS(brca_sub_kmeans, "data/tcga_kmeans.RDS")

# discrepancy table
knitr::kable(table(brca_subtype, brca_sub_kmeans$cluster))
```


3. Spectrum clustering: to scale or not to scale?

a) Apply PCA on the centered and scaled dataset. How many PCs should we use and why? You are encouraged to use `irlba::irlba()`.
    
Will use 2 PCs for the centered and scaled and 4 for the centered but not scaled
```{r centered and scaled, message=FALSE, warning=FALSE, echo=FALSE}
# center and scale the data
brca_sub_scaled_centered <- scale(as.matrix(brca_sub), center = T, scale = T)
brca_sub_unscaled_centered <- scale(as.matrix(brca_sub), center = T, scale = F)

# only calculate first few components using SVD by irlba()
## nv = 10: only calculate leading 10
svd_ret <- irlba::irlba(brca_sub_scaled_centered, nv = 10)
svd_ret_us <- irlba::irlba(brca_sub_unscaled_centered, nv = 10)

# Approximate the PVE
svd_var <- svd_ret$d^2/(nrow(brca_sub_scaled_centered)-1)
pve_apx <- svd_var/ncol(brca_sub)

svd_var_us <- svd_ret_us$d^2/(nrow(brca_sub_unscaled_centered)-1)
pve_apx_us <- svd_var_us/ncol(brca_sub)



qplot(c(1:10), pve_apx) +
  geom_line()+
  xlab("Principal Component") +
  ylab("Percentage Variance Explained") +
  ggtitle("Scree Plot Centered and Scaled")

qplot(c(1:10), pve_apx_us) +
  geom_line()+
  xlab("Principal Component") +
  ylab("Percentage Variance Explained") +
  ggtitle("Scree Plot Centered and Unscaled")
```
    
    
b) Plot PC1 vs PC2 of the centered and scaled data and PC1 vs PC2 of the centered but unscaled data side by side. Should we scale or not scale for clustering process? Why? (Hint: to put plots side by side, use `gridExtra::grid.arrange()` or `ggpubr::ggrrange()` or `egg::ggrrange()` for ggplots; use `fig.show="hold"` as chunk option for base plots)
    
```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height=10, fig.width=12, results='asis'}
# pc scores
pc_score <- (svd_ret$u[, 1:10])*(svd_ret$d[1:10])
pc_score_us <- (svd_ret_us$u[, 1:10])*(svd_ret_us$d[1:10])

scaled_centered <- data.table(x = pc_score[,1],
                y = pc_score[,2],
                col = as.factor(brca_subtype)) %>%
  ggplot() +
  geom_point(aes(x = x, y = y, col = col)) +
  theme_bw() +
  labs(color = "Cancer SubType") +
  xlab("PC1") +
  ylab("PC2") +
  ggtitle("Scaled and Centered")

unscaled_centered <- data.table(x = pc_score_us[,1],
                y = pc_score_us[,2],
                col = as.factor(brca_subtype)) %>%
  ggplot() +
  geom_point(aes(x = x, y = y, col = col)) +
  theme_bw() +
  labs(color = "Cancer Subtype") +
  xlab("PC1") +
  ylab("PC2") +
  ggtitle("Unscaled and Centered")

grid.arrange(scaled_centered, unscaled_centered, ncol = 2)
```
    

4. Spectrum clustering: center but do not scale the data

a) Use the first 4 PCs of the centered and unscaled data and apply kmeans. Find a reasonable number of clusters using within sum of squared with the elbow rule.
    
```{r message=FALSE, warning=FALSE, echo=FALSE}
# elbow methodfor optimal number of clusters
pca_elbow <- fviz_nbclust(pc_score_us[, 1:4], kmeans, method = "wss")

# 4 clusters
kmean_unscaled <- kmeans(x = pc_score_us[, 1:4], 3)
```
    
    
b) Choose an optimal cluster number and apply kmeans. Compare the real sub-type and the clustering label as follows: Plot scatter plot of PC1 vs PC2. Use point color to indicate the true cancer type and point shape to indicate the clustering label. Plot the kmeans centroids with black dots. Summarize how good is clustering results compared to the real sub-type.
    
```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height=10, fig.width=12, results='asis'}
centroids <- data.frame(x = kmean_unscaled$centers[,1],
                        y = kmean_unscaled$centers[,2],
                        col =levels(brca_subtype)[3],
                        cl = factor(1:3))

kmeans_pca_plot <- data.table(x = pc_score_us[,1],
                y = pc_score_us[,2],
                col = as.factor(brca_subtype),
                cl = as.factor(kmean_unscaled$cluster)) %>%
  ggplot(aes(x = x, y = y, col = col)) +
  geom_point(aes(shape = cl))+
  geom_point(data = centroids,color = "black", size = 3, stroke = 1)+
  theme_bw() +
  labs(color = "Cancer Subtype", shape = "Cluster") +
  xlab("PC1") +
  ylab("PC2") +
  ggtitle("Unscaled and Centered")

kmeans_pca_plot


```
    
c) Compare the clustering result from applying kmeans to the original data and the clustering result from applying kmeans to 4 PCs. Does PCA help in kmeans clustering? What might be the reasons if PCA helps?
    
```{r, echo=FALSE, fig.height=10, fig.width=12, results='asis'}
# elbow methodfor optimal number of clusters
orig_elbow <- fviz_nbclust(brca_sub, kmeans, method = "wss")

grid.arrange(orig_elbow, pca_elbow, ncol = 2)

```

```{r message=FALSE, warning=FALSE, fig.height=10, fig.width=12, results='asis', echo=FALSE}
kmean_brca <- kmeans(x = brca_sub, 4)

centroids_brca <- data.frame(x = kmean_brca$centers[,1],
                        y = kmean_brca$centers[,2],
                        col =levels(brca_subtype),
                        cl = factor(1:4))

# run kmeans on data but what x and y should you use??

kmeans_orig_plot<- data.table(x = pc_score_us[,1],
                y = pc_score_us[,2],
                col = as.factor(brca_subtype),
                cl = as.factor(kmean_brca$cluster)) %>%
  ggplot(aes(x = x, y = y, col = col)) +
  geom_point(aes(shape = cl))+
  geom_point(data = centroids_brca,color = "black", size = 3, stroke = 1)+
  theme_bw() +
  labs(color = "Cancer Subtype", shape = "Cluster") +
  xlab("PC1") +
  ylab("PC2") +
  ggtitle("Unscaled and Centered, kmeans Original")

grid.arrange(kmeans_orig_plot, kmeans_pca_plot, ncol = 2)
```
    
d) Now we have an x patient with breast cancer but with unknown sub-type. We have this patient's mRNA sequencing data. Project this x patient to the space of PC1 and PC2. (Hint: remember we remove some gene with no counts or no variablity, take log and centered) Plot this patient in the plot in iv) with a black dot. Calculate the Euclidean distance between this patient and each of centroid of the cluster. Can you tell which sub-type this patient might have? 
    
```{r message=FALSE, warning=FALSE, echo=FALSE, fig.height=10, fig.width=12, results='asis'}
x_patient <- read.csv("data/brca_x_patient.csv.gz", header = T) %>%
  select(which(subset_bool))
x_patient <- log2(x_patient+1e-10)

scaled_x_patient<- scale(x_patient, center= colMeans(brca_sub))
x_patient_pred <- scaled_x_patient %*% svd_ret$v


x_patient_projection <- data.frame(x = x_patient_pred[,1],
                        y = x_patient_pred[,2],
                        col =levels(brca_subtype)[1],
                        cl = 1)

data.table(x = pc_score_us[,1],
                y = pc_score_us[,2],
                col = as.factor(brca_subtype),
                cl = as.factor(kmean_unscaled$cluster)) %>%
  ggplot(aes(x = x, y = y, col = col)) +
  geom_point(aes(shape = cl))+
  geom_point(data = x_patient_projection,color = "black", size = 3, stroke = 1)+
  theme_bw() +
  labs(color = "Cancer Subtype", shape = "Cluster") +
  xlab("PC1") +
  ylab("PC2") +
  ggtitle("Unscaled and Centered")
```


# Case study 3: Auto data set

This question utilizes the `Auto` dataset from ISLR. The original dataset contains 408 observations about cars. It is similar to the CARS dataset that we use in our lectures. To get the data, first install the package ISLR. The `Auto` dataset should be loaded automatically. We'll use this dataset to practice the methods learn so far. 
Original data source is here: https://archive.ics.uci.edu/ml/datasets/auto+mpg

Get familiar with this dataset first. Tip: you can use the command `?ISLR::Auto` to view a description of the dataset. 

```{r echo=FALSE}
?ISLR::Auto
```


## EDA
Explore the data, with particular focus on pairwise plots and summary statistics. Briefly summarize your findings and any peculiarities in the data.


+ mpg summary
```{r auto mpg,  echo=FALSE}
summary(Auto$mpg)

mpg_box <- ggplot(Auto, aes(y=mpg)) +
  geom_boxplot()
```

+ cylinders summary
```{r auto cylinders,  echo=FALSE}
summary(Auto$cylinders)

cyl_box <- ggplot(Auto, aes(y=cylinders)) +
  geom_boxplot()
```

+ displacement summary
```{r auto displacement,  echo=FALSE}
summary(Auto$displacement)

disp_box <- ggplot(Auto, aes(y=displacement)) +
  geom_boxplot()
```

+ horsepower summary
```{r auto horsepower,  echo=FALSE}
summary(Auto$horsepower)

horse_box <- ggplot(Auto, aes(y=horsepower)) +
  geom_boxplot()
```

+ weight summary
```{r auto weight,  echo=FALSE}
summary(Auto$weight)

weight_box <- ggplot(Auto, aes(y=weight)) +
  geom_boxplot()
```

+ acceleration summary
```{r auto acceleration,  echo=FALSE}
summary(Auto$acceleration)

acc_box <- ggplot(Auto, aes(y=acceleration)) +
  geom_boxplot()
```

+ year summary

    total 13 years
    from 1970-1982

```{r auto origin,  echo=FALSE}
length(unique(Auto$origin))
summary(as.factor(Auto$origin))
```

+ Origin of car 
American: 245
European: 68
Japanese: 79

```{r auto name, echo =FALSE,  echo=FALSE}
length(unique(Auto$name))
#unique(Auto$name) %>% .[order(.)]
```

+ Auto names
    
    unique auto names: 301


```{r echo = FALSE, warning=F,message=FALSE,fig.height=10, fig.width=12, results='asis',  echo=FALSE}
# omit top panels to display correlation
panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...){
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- abs(cor(x, y))
    txt <- format(c(r, 0.123456789), digits = digits)[1]
    txt <- paste0(prefix, txt)
    if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
    text(0.5, 0.5, txt, cex = cex.cor * r)
}
select(Auto, colnames(Auto)[!(colnames(Auto) %in% c("name"))]) %>%
  pairs(lower.panel = panel.smooth,
      upper.panel = panel.cor, main="Scatterplot Matrix")
```

```{r echo = FALSE, warning=F,message=FALSE,fig.height=10, fig.width=12, results='asis',  echo=FALSE}
grid.arrange(mpg_box, cyl_box, disp_box,
             horse_box, weight_box, acc_box,
             ncol = 3)
```


## What effect does `time` have on `MPG`?

a) Start with a simple regression of `mpg` vs. `year` and report R's `summary` output. Is `year` a significant variable at the .05 level? State what effect `year` has on `mpg`, if any, according to this model.
    



```{r message=FALSE, warning=FALSE,results='asis',  echo=FALSE}
fit1 <- lm(mpg ~ year, data = Auto) 
stargazer(fit1, align=TRUE, ci = TRUE, type = "latex") 

```


      
_Year is significant at the 0.01 level. Our model is saying that for every year that goes by, there is about a 1.230 increase in the mpg of a car._

 b) Add `horsepower` on top of the variable `year` to your linear model. Is `year` still a significant variable at the .05 level? Give a precise interpretation of the `year`'s effect found here. (Table 4)_




```{r message=FALSE, warning=FALSE, results='asis',  echo=FALSE}
fit2 <- lm(mpg ~ year + horsepower, data = Auto) 
stargazer(fit2, align=TRUE, ci = TRUE, type = "latex") 
```


_Year is significant at the 0.01 level. Our model is saying that for every year that passes by, there is about a .657 increase in the mpg of a car. This effect size decreases from the previous one since we added horsepower to the dataset. (Table 5)_

c) The two 95% CI's for the coefficient of year differ among (i) and (ii). How would you explain the difference to a non-statistician?
    
_The confidence intervals got a lot smaller going from (i) to (ii). Since we added more information to the model (`horspower`) this reduces some of the variability that we see when we examine year alone. This reduction in conifidence interval means that we are likely getting more precise._

d) Create a model with interaction by fitting `lm(mpg ~ year * horsepower)`. Is the interaction effect significant at .05 level? Explain the year effect (if any). 


 

```{r message=FALSE, warning=FALSE, results='asis',  echo=FALSE}
fit2 <- lm(mpg ~ year * horsepower, data = Auto) 
stargazer(fit2, align=TRUE, ci = TRUE, type = output_format) 
```



_All of the variables are significant at the 0.01 level. Year is an extremely significant variable. Our model is saying that for every year that passes by, there is about a 2.190 increase in the mpg of a car. This effect size increases dramatically from the previous models. (Table 6)_

## Categorical predictors

Remember that the same variable can play different roles! Take a quick look at the variable `cylinders`, and try to use this variable in the following analyses wisely. We all agree that a larger number of cylinders will lower mpg. However, we can interpret `cylinders` as either a continuous (numeric) variable or a categorical variable.

a) Fit a model that treats `cylinders` as a continuous/numeric variable. Is `cylinders` significant at the 0.01 level? What effect does `cylinders` play in this model?

```{r message=FALSE, warning=FALSE,  echo=FALSE}
fit3 <- lm(mpg ~ cylinders, data = Auto) 
stargazer(fit3, align=TRUE, ci = TRUE, type = output_format) 
```
_Cylinders is significant at the 0.01 level. Our model is saying that for every 1 cylinder added, there is about a 3.560 increase in the mpg of a car. (Table 7)_

b) Fit a model that treats `cylinders` as a categorical/factor. Is `cylinders` significant at the .01 level? What is the effect of `cylinders` in this model? Describe the `cylinders` effect over `mpg`. 

```{r message=FALSE, warning=FALSE,  echo=FALSE}
fit4 <- lm(mpg ~ factor(cylinders), data = Auto) 
stargazer(fit4, align=TRUE, ci = TRUE, type = output_format) 
```

_Only 4 Cylinders is significant at the 0.01 level. Our model is saying that for every 1 cylinder added, there is about a 3.560 increase in the mpg of a car. (Table 7)_


c) What are the fundamental differences between treating `cylinders` as a continuous and categorical variable in your models? 

d) Can you test the null hypothesis: fit0: `mpg` is linear in `cylinders` vs. fit1: `mpg` relates to `cylinders` as a categorical variable at .01 level?  

_Yes you can using anova(H_0, H_1). There is strong evidence of rejecting the null hypothesis that fit0: `mpg` is linear in `cylinders` vs. fit1: `mpg` relates to `cylinders` as a categorical variable_

```{r message=FALSE, warning=FALSE, results='hold',  echo=FALSE}
test_anova <- anova(fit3, fit4)
test_anova
```



## Results

Final modeling question: we want to explore the effects of each feature as best as possible. You may explore interactions, feature transformations, higher order terms, or other strategies within reason. The model(s) should be as parsimonious (simple) as possible unless the gain in accuracy is significant from your point of view.
  
a) Describe the final model. Include diagnostic plots with particular focus on the model residuals and diagnoses.

b) Summarize the effects found.

c) Predict the `mpg` of the following car: A red car built in the US in 1983 that is 180 inches long, has eight cylinders, displaces 350 cu. inches, weighs 4000 pounds, and has a horsepower of 260. Also give a 95% CI for your prediction.


# [Case Study 4] Simple Regression through simulations
    
## Linear model through simulations

This exercise is designed to help you understand the linear model using simulations. In this exercise, we will generate $(x_i, y_i)$ pairs so that all linear model assumptions are met.

Presume that $\mathbf{x}$ and $\mathbf{y}$ are linearly related with a normal error $\boldsymbol{\varepsilon}$ , such that $\mathbf{y} = 1 + 1.2\mathbf{x} + \boldsymbol{\varepsilon}$. The standard deviation of the error $\varepsilon_i$ is $\sigma = 2$. 

We can create a sample input vector ($n = 40$) for $\mathbf{x}$ with the following code:

```{r, eval = T, echo = TRUE}
# Generates a vector of size 40 with equally spaced values between 0 and 1, inclusive
x = seq(0, 1, length = 40)
x
```


### Generate data

Create a corresponding output vector for $\mathbf{y}$ according to the equation given above. Use `set.seed(1)`. Then, create a scatterplot with $(x_i, y_i)$ pairs. Base R plotting is acceptable, but if you can, please attempt to use `ggplot2` to create the plot. Make sure to have clear labels and sensible titles on your plots.

```{r  message=F, echo =F}
set.seed(1)
y = 1 + 1.2*x + rnorm(40, 0, 2)
y
```

```{r  message=F, echo =F}
sim.data = data.frame(x, y)
sim.data
```


```{r  message=F, echo =F}
sim.data.plot = ggplot(sim.data) + 
  geom_point(aes(x, y)) + 
  labs(title = "Simulated Data", x = "x", y = "y")

sim.data.plot

```



### Understand the model
i. Find the LS estimates of $\boldsymbol{\beta}_0$ and $\boldsymbol{\beta}_1$, using the `lm()` function. What are the true values of $\boldsymbol{\beta}_0$ and $\boldsymbol{\beta}_1$? Do the estimates look to be good? 

```{r  message=F, echo =F}
fit0 = sim.data %>%
  lm(formula = y ~ x)
summary(fit0)
```


_LS estimate of $\boldsymbol{\beta}_0$ is 1.3 and $\boldsymbol{\beta}_1$ is 0.906._

  _The true value of $\boldsymbol{\beta}_0$ is 1_  

  _The true value of $\boldsymbol{\beta}_1$ is 1.2_

_The estimates appears to be slightly off from the true values, but they are relatively close._

ii. What is your RSE for this linear model fit? Is it close to $\sigma = 2$? 

_The RSE for this model is 1.79 which is pretty close to 2, slightly smaller._

ii. What is the 95% confidence interval for $\boldsymbol{\beta}_1$? Does this confidence interval capture the true $\boldsymbol{\beta}_1$?

_The 95% confidence interval for $\boldsymbol{\beta}_1$ is 0.906 +/- 0.959 = [-0.053, 1.865]. This confidence interval does capture the true $\boldsymbol{\beta}_1$ of 1.2. If we had more samples (higher N), this confidence interval would become narrower and more precise around the true value._

iii. Overlay the LS estimates and the true lines of the mean function onto a copy of the scatterplot you made above.
```{r  message=F, echo =F}
sim.data.plot2 = ggplot(sim.data, aes(x, y)) + 
  geom_point() + 
  labs(title = "Simulated Data", x = "x", y = "y") + 
  geom_abline(slope = 1.2, intercept = 1, color = "blue", show.legend = T) + 
  geom_smooth(method = "lm", se = T, color = "red", show.legend = T) + 
  annotate("text", x=0, y =.7, color = "blue", label = "True model") +
  annotate("text", x=0.12, y =1.7, color = "red", label = "Predicted model")

sim.data.plot2
```


### diagnoses

i. Provide residual plot where fitted $\mathbf{y}$-values are on the x-axis and residuals are on the y-axis. 

```{r  message=F, echo =F}
plot(fit0$fitted, fit0$residuals, 
     pch  = 16,
     main = "residual plot")
abline(h=0, lwd=4, col="red")
```


ii. Provide a normal QQ plot of the residuals.

```{r  message=F, echo =F}
qqnorm(fit0$residuals)
  qqline(fit0$residuals, lwd=4, col="blue")
```


iii. Comment on how well the model assumptions are met for the sample you used. 
_We observe relatively favorable homoscedastic data as well as quantiles which mostly follow a normal reference line. Another way to qualitatively check for normality is with a histogram._

```{r  message=F, echo =F}
set.seed(1)
sim.data %>%
  ggplot() + 
  geom_histogram(aes(x = x), bins = 10, color ="white", fill = "pink") + 
  labs(title = "Historgram of X", subtitle = "Mean X shown by red line", x = "X", y = "frequency") +
  geom_vline(aes(xintercept=mean(x)),
             color = "red", linetype = "dashed", size = 1)
```

_From this we can see the data is relatively normal and most likely follows linear model assumptions, but, conservatively, interpretation should proceed with caution as the distribution of the data may not be unimodal._



## Understand sampling distribution and confidence intervals

This part aims to help you understand the notion of sampling statistics and confidence intervals. Let's concentrate on estimating the slope only.  

Generate 100 samples of size $n = 40$, and estimate the slope coefficient from each sample. We include some sample code below, which should guide you in setting up the simulation. Note: this code is easier to follow but suboptimal; see the appendix for a more optimal R-like way to run this simulation.
```{r  message=F, echo =F}
# Inializing variables. Note b_1, upper_ci, lower_ci are vectors
x <- seq(0, 1, length = 40) 
n_sim <- 100              # number of simulations
b1 <- 0                   # n_sim many LS estimates of beta_1 (=1.2). Initialize to 0 for now
upper_ci <- 0             # upper bound for beta_1. Initialize to 0 for now.
lower_ci <- 0             # lower bound for beta_1. Initialize to 0 for now.
t_star <- qt(0.975, 38)   # Food for thought: why 38 instead of 40? What is t_star?

# Perform the simulation
for (i in 1:n_sim){
  y <- 1 + 1.2 * x + rnorm(40, sd = 2)
  lse <- lm(y ~ x)
  lse_output <- summary(lse)$coefficients
  se <- lse_output[2, 2]
  b1[i] <- lse_output[2, 1]
  upper_ci[i] <- b1[i] + t_star * se
  lower_ci[i] <- b1[i] - t_star * se
}
results <- as.data.frame(cbind(se, b1, upper_ci, lower_ci))

# remove unecessary variables from our workspace
rm(se, b1, upper_ci, lower_ci, x, n_sim, t_star, lse, lse_out) 
```

i. Summarize the LS estimates of $\boldsymbol{\beta}_1$ (stored in `results$b1`). Does the sampling distribution agree with theory? 


```{r  message=F, echo =F}
summary(results$b1)
```

_The mean of the sampling distribution of LS estimates for $\boldsymbol{\beta}_1$ is 1.15, which is very close too the true $\boldsymbol{\beta}_1$ of 1.2. Therefore, this sampling distribution shows strong support for the theory._

ii.  How many of your 95% confidence intervals capture the true $\boldsymbol{\beta}_1$? Display your confidence intervals graphically. 

```{r  message=F, echo =F}
CIs = cbind(results$lower_ci, results$upper_ci)
```


_Given that this is the 95% confidnce interval, we expect that 95% of our 100 confidence intervals will capture the true value of $\boldsymbol{\beta}_1$ _

```{r  message=F, echo =F}
mean(CIs[, 1] <= 1.2 & 1.2 <= CIs[, 2])
```

_Currently we see this is closer to 94%, which is relatively close. Whis intervals don't cover the treu value?_

```{r  message=F, echo =F}
ID = which(!(CIs[, 1] <= 1.2 & 1.2 <= CIs[, 2]))
```

```{r  message=F, echo =F}
plot(0, 
     xlim = c(-5,5), 
     ylim = c(1, 100), 
     ylab = "Sample", 
     xlab = "B1", 
     main = "Confidence Intervals")

colors = rep(gray(0.6), 100)
colors[ID] = "red"
abline(v = 1.2, lty = 2)
for(j in 1:100) {
  
  lines(c(CIs[j, 1], CIs[j, 2]), 
        c(j, j), 
        col = colors[j], 
        lwd = 2)
}
```

_Given the previously established 94% proportion of tru-value confidence intervals, the 6 red intervals out of hte 100 total intervals are an accurate deficiton of the 6% of intervals which do not contain the true value of $\boldsymbol{\beta}_1$ _




