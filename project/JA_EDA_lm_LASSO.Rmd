---
title: "JA EDA and lm/LASSO analysis"
author:
- Jenea Adams
- Annan Timon
date: 'april 26'
output:
  html_document:
    code_folding: show
    highlight: haddock
    theme: lumen
    toc: yes
    toc_depth: 4
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '4'
  word_document:
    toc: yes
    toc_depth: '4'
urlcolor: blue  
---

# Packages & Data

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.height=4, fig.width=7, fig.align = 'center', warning = F)
if (!require("pacman")) install.packages("pacman")
pacman::p_load(sf, readxl, tidyverse, ggplot2, ggpmisc, ggpubr, censusxy, tigris, ndi, dplyr, mapview, tidycensus, RColorBrewer, leaps, skimr, reshape2, glmnet, ggpubr) 
```

Read in data 
```{r}
census_disp = read.csv("data/census_healthdisp_cleaned.csv")
head(census_disp)
```


```{r}

str(census_disp)

# write.csv(str(census_disp), "data/final_vars.csv")
```



## organizing data 
```{r}
census_disp = census_disp %>%
  mutate(TractFIPS = as.character(TractFIPS), 
         YEAR = as.factor(YEAR)) %>%
  rename(heat_health_impacts = N_VERYHIGH) %>%
  mutate(heat_health_impacts = as.factor(heat_health_impacts)) %>%
  select(-X)
```



# Data Dictionary 

https://www.tablesgenerator.com/markdown_tables

[insert data dictionary here]


# EDA 

## census NDI package
```{r}

# tidycensus::census_api_key("3352b422b0ef5aaabae7a20651522b5a7688e0bf", install = T, overwrite = T)


gini2010philly = gini(geo = "tract", state = "PA", county = "Philadelphia", year = 2010)

gini2010philly$gini

tracts2010philly = tigris::tracts(state = "PA", county = "Philadelphia", year = 2010, cb = TRUE) %>%
  mutate(GEO_ID = gsub("1400000US","", GEO_ID)) %>%
  dplyr::rename(GEOID = GEO_ID)

tracts2010philly$GEOID


tracts2010philly_gini = dplyr::left_join(tracts2010philly, gini2010philly$gini, by = "GEOID")
```

```{r}
tracts2010philly2 = tracts2010philly %>%
  rename(TractFIPS = GEOID)
census_disp_geo = left_join(tracts2010philly2, census_disp, by = "TractFIPS")
```


```{r}
# tracts2010philly_gini$gini
```


```{r}
tracts2010philly_gini %>%
  ggplot() +
  geom_sf(data = tracts2010philly_gini,
          aes(fill = gini),
          color = "white") +
  # guides(fill = F) +
  labs(title = "") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```


```{r}
tracts2010philly_gini %>%
  ggplot() +
  geom_sf(data = tracts2010philly_gini,
          aes(fill = gini),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()

```
Having some issues by getting all NA values for the gini index, thus resulting in a blank map. 




```{r}
census_disp %>%
  ggplot(aes(x = gini, y = walk_score, color = CANCER_CrudePrev)) + 
  geom_point(alpha = 0.5) + 
  geom_smooth(method = "lm", se = F, color = "orange", ) + 
  stat_poly_eq(use_label(c("R2"))) +
  theme_bw()
```

```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(aes(fill = CANCER_CrudePrev),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```



```{r}
census_disp %>%
  ggplot(aes(x = gini, y = avgPCT_HPSS, color = BPHIGH_CrudePrev)) + 
  geom_point(alpha = 0.5) + 
  geom_smooth(method = "lm", se = F, color = "orange", ) + 
  # stat_poly_eq(use_label(c("eq", "R2"))) +
  theme_bw()
```

```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(aes(fill = BPHIGH_CrudePrev),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```



```{r}
census_disp %>%
  ggplot(aes(x = gini, y = avgPCT_HPSS, color = avgPCT_POVERTY)) + 
  geom_point(alpha = 0.5) + 
  geom_smooth(method = "lm", se = F, color = "orange", ) + 
  # stat_poly_eq(use_label(c("eq", "R2"))) +
  theme_bw()
```

```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(aes(fill = avgPCT_POVERTY),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```



```{r}
census_disp %>%
  ggplot(aes(x = SLEEP_CrudePrev, y = gini, color = avgHPSS_PER1000 , shape = heat_health_impacts)) + 
  geom_point(alpha = 0.5) + 
  # geom_smooth(method = "lm", se = F, color = "orange", ) +
  # stat_poly_eq(use_label(c("eq", "R2"))) +
  theme_bw()
```


```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(aes(fill = avgHPSS_PER1000),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```

```{r}
colnames(census_disp)
```


```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(aes(fill = HVI_SCORE),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```

```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(data = census_disp_geo, aes(fill = MHLTH_CrudePrev),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```

```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(data = census_disp_geo, aes(fill = SLEEP_CrudePrev),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```


```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(data = census_disp_geo, aes(fill = sumTOTAL_UNITS),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```

```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(data = census_disp_geo, aes(fill = DIABETES_CrudePrev),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```

```{r}
# census_disp_geo %>%
#   select(PERCENT_WHITE_NH, PERCENT_BLACK_NH, PERCENT_ASIAN_NH, PERCENT_HISPANIC) %>%
#   ggplot() +
#   geom_sf(data = census_disp_geo, aes(fill = DIABETES_CrudePrev),
#           color = "white") +
#   ggplot2::scale_fill_viridis_c() +
#   theme_void()
```


```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(data = census_disp_geo, aes(fill = pct_hosp),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```

```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(data = census_disp_geo, aes(fill = transit_score),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```

```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(data = census_disp_geo, aes(fill = walk_score),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```


```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(data = census_disp_geo, aes(fill = OBESITY_CrudePrev),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```

```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(data = census_disp_geo, aes(fill = TEETHLOST_CrudePrev),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```

```{r}
census_disp_geo %>%
  ggplot() +
  geom_sf(data = census_disp_geo, aes(fill = avgLPSS_PER1000),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()
```




```{r}
census_disp %>%
  ggplot(aes(gini)) + 
  geom_histogram() + 
  theme_bw()
  
```

```{r}
census_disp %>%
  ggplot(aes(gini,
             fill = heat_health_impacts)) + 
  geom_histogram(color = "white") + 
  guides(alpha = F, color = F)+
  scale_fill_brewer(palette="Dark2") +
  theme_bw()
```

```{r}
mean(!is.na(census_disp$gini))

census_disp %>%
  mutate(gini_i = ifelse(gini > 0.4531, 1, 0), 
         gini_i = as.factor(gini_i)) %>%
  ggplot(aes(CANCER_CrudePrev,
             fill = gini_i)) + 
  geom_histogram(color = "white") + 
  guides(alpha = F, 
         color = F, 
         fill = (guide_legend(title = "Gini Index > mean")))+
  scale_fill_brewer(palette="Dark2", labels = c("Yes", "No", "NA")) +
  geom_vline(aes(xintercept=mean(CANCER_CrudePrev)),
            color="black", linetype="dashed", size=1)
  theme_bw()
```

```{r}
census_disp %>%
  mutate(gini_i = ifelse(gini > 0.4531, 1, 0), 
         gini_i = as.factor(gini_i)) %>%
  ggplot(aes(BPHIGH_CrudePrev,
             fill = gini_i)) + 
  geom_histogram(color = "white") + 
  guides(alpha = F, 
         color = F, 
         fill = (guide_legend(title = "Gini Index > mean")))+
  scale_fill_brewer(palette="Dark2", labels = c("Yes", "No", "NA")) +
  geom_vline(aes(xintercept=mean(BPHIGH_CrudePrev)),
            color="black", linetype="dashed", size=1)
  theme_bw()
```



```{r}
p1 = census_disp_geo %>%
  ggplot() +
  geom_sf(data = census_disp_geo,
          aes(fill = gini),
          color = "white") +
  ggplot2::scale_fill_viridis_c() +
  theme_void()

p2 = census_disp_geo %>%
  ggplot() +
  geom_sf(data = census_disp_geo,
          aes(fill = ARTHRITIS_CrudePrev),
          color = "white") +
  # scale_fill_gradient2() +
  ggplot2::scale_fill_viridis_c(option = "plasma") +
  # guides(fill = guide_legend(title = "[health indicator]")) +
  theme_void()

p3 = census_disp_geo %>%
  ggplot() +
  geom_sf(data = census_disp_geo,
          aes(fill = HIGHCHOL_CrudePrev),
          color = "white") +
  # scale_fill_gradient2() +
  ggplot2::scale_fill_viridis_c(option = "plasma") +
  # guides(fill = guide_legend(title = "[health indicator]")) +
  theme_void()

ggarrange(p1, p2, p3, ncol = 2, nrow = 2)
```

```{r}
census_disp_geo %>%
  ggplot(aes(x = ACCESS2_CrudePrev, y = avgPCT_VEHICLE_AVAIL)) + 
  geom_point() +
  geom_smooth(method = "lm") + 
  stat_poly_eq(use_label(c("eq", "R2"))) + 
  theme_bw()
```

```{r}
census_disp_geo %>%
  ggplot(aes(x = ARTHRITIS_CrudePrev, y = gini)) + 
  geom_point() +
  geom_smooth(method = "lm") + 
  stat_poly_eq(use_label(c("eq", "R2"))) + 
  theme_bw()
```

```{r}
census_disp_geo %>%
  ggplot(aes(x = MAMMOUSE_CrudePrev, y = gini)) + 
  geom_point() +
  geom_smooth(method = "lm") + 
  stat_poly_eq(use_label(c("eq", "R2"))) + 
  theme_bw()
```

```{r}
census_disp_geo %>%
  ggplot(aes(x = TEETHLOST_CrudePrev, y = gini)) + 
  geom_point() +
  geom_smooth(method = "lm") + 
  stat_poly_eq(use_label(c("eq", "R2"))) + 
  theme_bw()
```


```{r}
str(census_disp_geo)
```



```{r}
colnames(census_disp_geo)
```


# model data prep 

```{r}
final_data = readRDS("data/final_data.RDS") %>%
  # select(-COUNT_ALL_RACES_ETHNICITIES) %>%
  mutate(heat_health_effects = as.factor(N_VERYHIGH)) %>%
  select(-N_VERYHIGH)
```


```{r}
# str(final_data)
```

```{r}
# census_disp2 = census_disp %>%
#   select(-YEAR, -lat, -lon, )
```

```{r}
summary(final_data)
```


```{r}
str(final_data)
```

# lm() - predicting gini

```{r}
fit.all = lm(data = final_data[-1], gini ~ .)
summary(fit.all)
```

Forward selection
```{r}
fit.forward = regsubsets(gini ~., final_data[-1], nvmax = 60, method = "forward")
summary(fit.forward)

```

Backward selection
```{r}
fit.backward = regsubsets(gini ~., final_data[-1], nvmax = 60, method = "backward")
summary(fit.backward)
```

```{r}
fit.backward$w
```


exhaustive search 
```{r}
# fit.exh = regsubsets(gini ~., final_data[-1], nvmax = 50, method = "exhaustive", really.big = T)
```



# lm() - predicting diseases

prep from AT 
```{r}
health_columns <- c(1, grep("[A-Z]*_CrudePrev",colnames(final_data)))
demog_columns <- colnames(final_data)[grep("COUNT_.*|PERCENT_.*",colnames(final_data))]
Ys <- colnames(final_data)[health_columns]
features <- colnames(final_data)[!(colnames(final_data) %in% Ys) &
                                        !(colnames(final_data) %in% demog_columns)]

Ys #health stuff
features
```


```{r}

# models = matrix(nrow = length(Ys[-1]), ncol = length(features))

models = list()
all_ps = list()
betas = list()
  
for(i in 1:length(Ys[-1])){
  f = as.formula(
  paste(Ys[i], 
        paste(features, collapse = " + "), 
        sep = " ~ "))
  
  #get model and add to list 
  model = lm(f, final_data)
  models[[Ys[-1][i]]] = model
  
  #get significant ps
  p = coef(summary(model))[,4]
  all_ps[[Ys[-1][i]]] = p 
  
  #get betas
  beta = coef(summary(model))[,1]
  betas[[Ys[-1][i]]] = beta
  
  
}

# print(f)
ps.df<- as.tibble(all_ps)
betas.df<- as.tibble(betas)

betas.df$variables <- names(betas[[1]])

betas.df

# models
# 
# sig_ps
# 
# betas

```

```{r, fig.width=12, fig.height=10}
dim(final_data)

library(viridis)
# funtion to color non significant values white
makeColorRampPalette <- function(colors, cutoff.fraction, num.colors.in.palette)
{
  stopifnot(length(colors) == 4)
  ramp1 <- colorRampPalette(colors[1:2])(num.colors.in.palette * cutoff.fraction)
  ramp2 <- colorRampPalette(colors[3:4])(num.colors.in.palette * (1 - cutoff.fraction))
  return(c(ramp1, ramp2))
}


change_matrix <- function(p_mat, beta_mat) {
    new_mat <- matrix(nrow = nrow(p_mat), ncol = ncol(p_mat)-1)
    
    # iterate through and find values that are not significant
    for(i in 1:nrow(new_mat)) {
        for(j in 1:ncol(new_mat)) {
            
            if(p_mat[i,j] < .05) {
                new_mat[i,j] <- beta_mat[i,j]
                if(beta_mat[i,j] == "Inf") { 
                    new_mat[i,j] <- NA
                }
                
            }else {
                new_mat[i,j] <- NA
            }
        }
    }
    
    #print(new_mat)

    
    rownames(new_mat) <- p_mat$variables
    colnames(new_mat) <- colnames(p_mat)[1:(length(p_mat)-1)]
    
    
    return(data.frame(new_mat))                                      
# -

}

significant_df <- change_matrix(ps.df, as.data.frame(betas.df))
pheatmap(t(significant_df[-1,]), na_col = "#FFFFFFFF",
         cluster_cols = F, cluster_rows = F,
         color = inferno(10))

```


finding significant Ps
```{r}

summary(models$CANCER_CrudePrev)$coefficients[,4] #extract p-vales from an individual model 

significant_df

```


# LASSO gini

```{r}
# Y = final_data$gini
# X = model.matrix(gini~., data = final_data[-1])[,-1]
# 
# set.seed(1)
# pen.fac = rep(1, ncol(X))
# # pen.fac[grep('^State', colnames(X))] = 0
# 
# 
# fit.force.cv = cv.glmnet(X, Y, alpha = 1, nfolds = 12, intercept = T, #alpha is the 
#                          penalty.factor = pen.fac)
# 
# coef.min = coef(fit.force.cv, s = "lambda.1se") # gives a more parsimonious and simpler model; result that is within one standard error fo the minimum, but the minimum? 
# coef.min = coef.min[which(coef.min !=0),]
# coef.min
# length(rownames(as.matrix(coef.min))[-1]) #get rid of the intercept 
```

# LASSO - predicting diseases 

LASSO loop
```{r}
# 
# models = list()
# all_ps = list()
# betas = list()

lasso_models = list()
plots = list()
lasso_coefs = list()

models_min = list()
all_ps_min = list()
betas_min = list()

for(i in 1:length(Ys[-1])){
  f = as.formula(
  paste(Ys[-1][i], 
        paste(features, collapse = " + "), 
        sep = " ~ "))
  
  cur_feature <- Ys[-1][i]
  y <- final_data %>% dplyr::select(!!cur_feature)
  X1 <- model.matrix(f, final_data)[, -1]
  fit.lasso <- cv.glmnet(X1, y[[1]], alpha=1)
  
  lasso_models[[Ys[-1][i]]] = fit.lasso #save model 
  plots[[Ys[-1][i]]] = plot(fit.lasso) # save plot 
  
  #get coefs
  coef.min = coef(fit.lasso, s = "lambda.1se")
  coef.min = coef.min[which(coef.min !=0),]
  lasso_coefs[[Ys[-1][i]]] = coef.min
  
  
  features_sub <- rownames(as.matrix(coef.min))[-1]
  
  if (sum(grepl("heat_health.*", features_sub)) > 0) {
    index = grep("heat_health.*", features_sub)
    features_sub[index] = substr(features_sub[index], 1, nchar(features_sub[index])-1)
  }
  
  final_data_sub <- final_data %>% dplyr::select(all_of(c(Ys[-1][i], features_sub)))
  
  f_new <- as.formula(
  paste(Ys[-1][i], 
        paste(features_sub, collapse = " + "), 
        sep = " ~ "))
  model_min = lm(f_new, final_data_sub)
  
  #get model and add to list 
  models_min[[Ys[-1][i]]] = model_min
  
  #get significant ps
  p = coef(summary(model_min))[,4]
  all_ps_min[[Ys[-1][i]]] = p 
  
  #get betas
  beta = coef(summary(model_min))[,1]
  betas_min[[Ys[-1][i]]] = beta
  
}


summary(models_min$ACCESS2_CrudePrev)

summary(models_min$CANCER_CrudePrev)

summary(models_min$CASTHMA_CrudePrev)

summary(models_min$STROKE_CrudePrev)

summary(models_min$DIABETES_CrudePrev)

```


# test train split 


# glm()


# Model Evaluation 

How well can these models predict health and quality of life 

## ROC


# Discussion points and Future Directions 

- Look at interaction between related models 
